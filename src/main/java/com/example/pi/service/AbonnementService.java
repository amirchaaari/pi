package com.example.pi.service;

import com.example.pi.entity.Abonnement;
import com.example.pi.entity.Pack;
import com.example.pi.entity.UserInfo;
import com.example.pi.interfaces.IAbonnementService;
import com.example.pi.repository.AbonnementRepository;
import com.example.pi.repository.PackRepository;
import com.example.pi.repository.UserInfoRepository;
import lombok.AllArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.crossstore.ChangeSetPersister;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.scheduling.annotation.Schedules;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;

@Service
@AllArgsConstructor
public class AbonnementService implements IAbonnementService {

    @Autowired
    private final AbonnementRepository abonnementRepository;
    private final PackRepository packRepository;
    private final UserInfoRepository userInfoRepository;
    private TrophyService trophyService;

    // M√©thode pour r√©cup√©rer l'utilisateur connect√©
    private UserInfo getCurrentUser() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userInfoRepository.findByEmail(username).orElse(null);
    }


    // Le Club Owner peut modifier les informations d‚Äôun abonnement
    @Override
    public Abonnement updateAbonnement(Long id, Abonnement newAbonnement) {
        Optional<Abonnement> optional = abonnementRepository.findById(id);
        if (optional.isEmpty()) return null;

        Abonnement old = optional.get();
        UserInfo currentUser = getCurrentUser();
        if (currentUser == null) return null;

        int ownerId = old.getPack().getClub().getOwner().getId();
        if (currentUser.getId() == ownerId) {
            old.setStartDate(newAbonnement.getStartDate());
            old.setEndDate(newAbonnement.getEndDate());
            old.setStatus(newAbonnement.getStatus());
            return abonnementRepository.save(old);
        }

        return null;
    }

    // Un utilisateur ou Club Owner peut supprimer l'abonnement
    @Override
    public void deleteAbonnement(Long id) {
        Optional<Abonnement> optional = abonnementRepository.findById(id);
        if (optional.isEmpty()) return;

        Abonnement abonnement = optional.get();
        UserInfo currentUser = getCurrentUser();
        if (currentUser == null) return;

        int userId = currentUser.getId();
        int ownerId = abonnement.getPack().getClub().getOwner().getId();

        if (abonnement.getUser().getId() == userId || userId == ownerId) {
            abonnementRepository.deleteById(id);
        }
    }

    @Override
    public Abonnement getAbonnementById(Long id) {


        return abonnementRepository.findById(id).orElse(null);
    }

    @Override
    public List<Abonnement> getAllAbonnements() {
        List<Abonnement> abonnements = abonnementRepository.findAll();

        if (abonnements.isEmpty()) {
            System.out.println("Aucun abonnement trouv√©");
        }

        return abonnements;
    }





    public List<Abonnement> getUserAbonnementsHistory() {
        UserInfo currentUser = getCurrentUser();
        if (currentUser == null) return Collections.emptyList();  // Si l'utilisateur n'est pas trouv√©, renvoyer une liste vide

        // R√©cup√©rer tous les abonnements associ√©s √† cet utilisateur
        return abonnementRepository.findByUserId(currentUser.getId());
    }


    public Abonnement renewAbonnement(Long abonnementId, LocalDate newEndDate) {
        // Validate input
        if (newEndDate.isBefore(LocalDate.now())) {
            throw new IllegalArgumentException("La nouvelle date ne peut pas √™tre dans le pass√©.");
        }

        // Get subscription
        Abonnement abonnement = abonnementRepository.findById(abonnementId)
                .orElseThrow(() -> new IllegalArgumentException("Abonnement non trouv√©."));

        UserInfo currentUser = getCurrentUser();

        // Verify ownership
        if (!abonnement.getUser().equals(currentUser)) {

        }

        LocalDate currentEndDate = abonnement.getEndDate();

        // Prevent renewal to an earlier date
        if (newEndDate.isBefore(currentEndDate)) {
            throw new IllegalArgumentException("La nouvelle date doit √™tre apr√®s la date de fin actuelle.");
        }

        try {
            // Calculate points
            long days = ChronoUnit.DAYS.between(currentEndDate, newEndDate);
            int gainedPoints = (int) days * 2;

            // Update user points
            currentUser.setPoints(currentUser.getPoints() + gainedPoints);
            userInfoRepository.save(currentUser);

            // Update subscription
            abonnement.setEndDate(newEndDate);
            abonnement.setEndDateOfRenewal(newEndDate);
            abonnement.setStatus("actif");
            abonnement = abonnementRepository.save(abonnement);

            // Update trophies
            trophyService.updateUserTrophies(currentUser);

            return abonnement;

        } catch (Exception e) {
            // Log the error
            throw new RuntimeException("Erreur lors du renouvellement de l'abonnement");
        }
    }

    public double calculateRenewalRateForClub(Long clubId) {
        List<Abonnement> abonnements = abonnementRepository.findByPackClubId(clubId);

        if (abonnements.isEmpty()) return 0.0;

        long totalAbonnements = abonnements.size();
        long renouvellements = abonnements.stream()
                .filter(a -> a.getEndDateOfRenewal() != null)
                .count();

        return (double) renouvellements / totalAbonnements * 100;
    }

    @Override
    public Map<String, Object> analyzeClubPerformance(Long clubId) {
        Map<String, Object> response = new HashMap<>();

        // Popularit√© des packs
        List<Pack> packs = packRepository.findByClubId(clubId);
        List<Map<String, Object>> packPerformanceList = new ArrayList<>();

        if (packs.isEmpty()) {
            response.put("message", "‚ùå Aucun pack trouv√© pour ce club.");
        } else {
            packs.forEach(pack -> {
                Map<String, Object> packDTO = new HashMap<>();
                packDTO.put("packName", pack.getName());
                packDTO.put("subscriptionCount", pack.getSubscriptionCount());
                packPerformanceList.add(packDTO);
            });
            response.put("packPerformance", packPerformanceList);
            response.put("message", "‚úÖ Analyse de performance du club r√©ussie.");
        }

        // Taux de renouvellement
        double taux = calculateRenewalRateForClub(clubId);
        response.put("renewalRate", taux);

        // Interpr√©tation
        String interpretation;
        if (taux >= 70) {
            interpretation = "üî• Tr√®s bon taux de fid√©lisation !";
        } else if (taux >= 40) {
            interpretation = "‚ö†Ô∏è Taux de fid√©lisation moyen.";
        } else {
            interpretation = "‚ùå Faible fid√©lisation, √† am√©liorer.";
        }
        response.put("interpretation", interpretation);

        return response;
    }


     @Scheduled( cron = "0 */1 * * * ?")
    public void checkAndExpireAbonnements() {
         List<Abonnement> abonnements = abonnementRepository.findAll();
         LocalDate today = LocalDate.now();

         for (Abonnement abonnement : abonnements) {
             if (abonnement.getEndDate().isBefore(today)) {
                 abonnement.setStatus("expired");
                 abonnementRepository.save(abonnement);
             }else{
                    abonnement.setStatus("actif");
                    abonnementRepository.save(abonnement);
             }
         }
     }









}
